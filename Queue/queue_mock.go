package queue

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i queue.QueueInterface -o ./queue_mock.go -n QueueInterfaceMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// QueueInterfaceMock implements QueueInterface
type QueueInterfaceMock struct {
	t minimock.Tester

	funcPop          func(node QueueNodeInt) (q1 QueueNodeInt, err error)
	inspectFuncPop   func(node QueueNodeInt)
	afterPopCounter  uint64
	beforePopCounter uint64
	PopMock          mQueueInterfaceMockPop

	funcPull          func() (q1 QueueNodeInt, err error)
	inspectFuncPull   func()
	afterPullCounter  uint64
	beforePullCounter uint64
	PullMock          mQueueInterfaceMockPull

	funcPush          func(node QueueNodeInt) (q1 QueueNodeInt, err error)
	inspectFuncPush   func(node QueueNodeInt)
	afterPushCounter  uint64
	beforePushCounter uint64
	PushMock          mQueueInterfaceMockPush
}

// NewQueueInterfaceMock returns a mock for QueueInterface
func NewQueueInterfaceMock(t minimock.Tester) *QueueInterfaceMock {
	m := &QueueInterfaceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PopMock = mQueueInterfaceMockPop{mock: m}
	m.PopMock.callArgs = []*QueueInterfaceMockPopParams{}

	m.PullMock = mQueueInterfaceMockPull{mock: m}

	m.PushMock = mQueueInterfaceMockPush{mock: m}
	m.PushMock.callArgs = []*QueueInterfaceMockPushParams{}

	return m
}

type mQueueInterfaceMockPop struct {
	mock               *QueueInterfaceMock
	defaultExpectation *QueueInterfaceMockPopExpectation
	expectations       []*QueueInterfaceMockPopExpectation

	callArgs []*QueueInterfaceMockPopParams
	mutex    sync.RWMutex
}

// QueueInterfaceMockPopExpectation specifies expectation struct of the QueueInterface.Pop
type QueueInterfaceMockPopExpectation struct {
	mock    *QueueInterfaceMock
	params  *QueueInterfaceMockPopParams
	results *QueueInterfaceMockPopResults
	Counter uint64
}

// QueueInterfaceMockPopParams contains parameters of the QueueInterface.Pop
type QueueInterfaceMockPopParams struct {
	node QueueNodeInt
}

// QueueInterfaceMockPopResults contains results of the QueueInterface.Pop
type QueueInterfaceMockPopResults struct {
	q1  QueueNodeInt
	err error
}

// Expect sets up expected params for QueueInterface.Pop
func (mmPop *mQueueInterfaceMockPop) Expect(node QueueNodeInt) *mQueueInterfaceMockPop {
	if mmPop.mock.funcPop != nil {
		mmPop.mock.t.Fatalf("QueueInterfaceMock.Pop mock is already set by Set")
	}

	if mmPop.defaultExpectation == nil {
		mmPop.defaultExpectation = &QueueInterfaceMockPopExpectation{}
	}

	mmPop.defaultExpectation.params = &QueueInterfaceMockPopParams{node}
	for _, e := range mmPop.expectations {
		if minimock.Equal(e.params, mmPop.defaultExpectation.params) {
			mmPop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPop.defaultExpectation.params)
		}
	}

	return mmPop
}

// Inspect accepts an inspector function that has same arguments as the QueueInterface.Pop
func (mmPop *mQueueInterfaceMockPop) Inspect(f func(node QueueNodeInt)) *mQueueInterfaceMockPop {
	if mmPop.mock.inspectFuncPop != nil {
		mmPop.mock.t.Fatalf("Inspect function is already set for QueueInterfaceMock.Pop")
	}

	mmPop.mock.inspectFuncPop = f

	return mmPop
}

// Return sets up results that will be returned by QueueInterface.Pop
func (mmPop *mQueueInterfaceMockPop) Return(q1 QueueNodeInt, err error) *QueueInterfaceMock {
	if mmPop.mock.funcPop != nil {
		mmPop.mock.t.Fatalf("QueueInterfaceMock.Pop mock is already set by Set")
	}

	if mmPop.defaultExpectation == nil {
		mmPop.defaultExpectation = &QueueInterfaceMockPopExpectation{mock: mmPop.mock}
	}
	mmPop.defaultExpectation.results = &QueueInterfaceMockPopResults{q1, err}
	return mmPop.mock
}

//Set uses given function f to mock the QueueInterface.Pop method
func (mmPop *mQueueInterfaceMockPop) Set(f func(node QueueNodeInt) (q1 QueueNodeInt, err error)) *QueueInterfaceMock {
	if mmPop.defaultExpectation != nil {
		mmPop.mock.t.Fatalf("Default expectation is already set for the QueueInterface.Pop method")
	}

	if len(mmPop.expectations) > 0 {
		mmPop.mock.t.Fatalf("Some expectations are already set for the QueueInterface.Pop method")
	}

	mmPop.mock.funcPop = f
	return mmPop.mock
}

// When sets expectation for the QueueInterface.Pop which will trigger the result defined by the following
// Then helper
func (mmPop *mQueueInterfaceMockPop) When(node QueueNodeInt) *QueueInterfaceMockPopExpectation {
	if mmPop.mock.funcPop != nil {
		mmPop.mock.t.Fatalf("QueueInterfaceMock.Pop mock is already set by Set")
	}

	expectation := &QueueInterfaceMockPopExpectation{
		mock:   mmPop.mock,
		params: &QueueInterfaceMockPopParams{node},
	}
	mmPop.expectations = append(mmPop.expectations, expectation)
	return expectation
}

// Then sets up QueueInterface.Pop return parameters for the expectation previously defined by the When method
func (e *QueueInterfaceMockPopExpectation) Then(q1 QueueNodeInt, err error) *QueueInterfaceMock {
	e.results = &QueueInterfaceMockPopResults{q1, err}
	return e.mock
}

// Pop implements QueueInterface
func (mmPop *QueueInterfaceMock) Pop(node QueueNodeInt) (q1 QueueNodeInt, err error) {
	mm_atomic.AddUint64(&mmPop.beforePopCounter, 1)
	defer mm_atomic.AddUint64(&mmPop.afterPopCounter, 1)

	if mmPop.inspectFuncPop != nil {
		mmPop.inspectFuncPop(node)
	}

	mm_params := &QueueInterfaceMockPopParams{node}

	// Record call args
	mmPop.PopMock.mutex.Lock()
	mmPop.PopMock.callArgs = append(mmPop.PopMock.callArgs, mm_params)
	mmPop.PopMock.mutex.Unlock()

	for _, e := range mmPop.PopMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmPop.PopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPop.PopMock.defaultExpectation.Counter, 1)
		mm_want := mmPop.PopMock.defaultExpectation.params
		mm_got := QueueInterfaceMockPopParams{node}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPop.t.Errorf("QueueInterfaceMock.Pop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPop.PopMock.defaultExpectation.results
		if mm_results == nil {
			mmPop.t.Fatal("No results are set for the QueueInterfaceMock.Pop")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmPop.funcPop != nil {
		return mmPop.funcPop(node)
	}
	mmPop.t.Fatalf("Unexpected call to QueueInterfaceMock.Pop. %v", node)
	return
}

// PopAfterCounter returns a count of finished QueueInterfaceMock.Pop invocations
func (mmPop *QueueInterfaceMock) PopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPop.afterPopCounter)
}

// PopBeforeCounter returns a count of QueueInterfaceMock.Pop invocations
func (mmPop *QueueInterfaceMock) PopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPop.beforePopCounter)
}

// Calls returns a list of arguments used in each call to QueueInterfaceMock.Pop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPop *mQueueInterfaceMockPop) Calls() []*QueueInterfaceMockPopParams {
	mmPop.mutex.RLock()

	argCopy := make([]*QueueInterfaceMockPopParams, len(mmPop.callArgs))
	copy(argCopy, mmPop.callArgs)

	mmPop.mutex.RUnlock()

	return argCopy
}

// MinimockPopDone returns true if the count of the Pop invocations corresponds
// the number of defined expectations
func (m *QueueInterfaceMock) MinimockPopDone() bool {
	for _, e := range m.PopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPop != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		return false
	}
	return true
}

// MinimockPopInspect logs each unmet expectation
func (m *QueueInterfaceMock) MinimockPopInspect() {
	for _, e := range m.PopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QueueInterfaceMock.Pop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		if m.PopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to QueueInterfaceMock.Pop")
		} else {
			m.t.Errorf("Expected call to QueueInterfaceMock.Pop with params: %#v", *m.PopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPop != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		m.t.Error("Expected call to QueueInterfaceMock.Pop")
	}
}

type mQueueInterfaceMockPull struct {
	mock               *QueueInterfaceMock
	defaultExpectation *QueueInterfaceMockPullExpectation
	expectations       []*QueueInterfaceMockPullExpectation
}

// QueueInterfaceMockPullExpectation specifies expectation struct of the QueueInterface.Pull
type QueueInterfaceMockPullExpectation struct {
	mock *QueueInterfaceMock

	results *QueueInterfaceMockPullResults
	Counter uint64
}

// QueueInterfaceMockPullResults contains results of the QueueInterface.Pull
type QueueInterfaceMockPullResults struct {
	q1  QueueNodeInt
	err error
}

// Expect sets up expected params for QueueInterface.Pull
func (mmPull *mQueueInterfaceMockPull) Expect() *mQueueInterfaceMockPull {
	if mmPull.mock.funcPull != nil {
		mmPull.mock.t.Fatalf("QueueInterfaceMock.Pull mock is already set by Set")
	}

	if mmPull.defaultExpectation == nil {
		mmPull.defaultExpectation = &QueueInterfaceMockPullExpectation{}
	}

	return mmPull
}

// Inspect accepts an inspector function that has same arguments as the QueueInterface.Pull
func (mmPull *mQueueInterfaceMockPull) Inspect(f func()) *mQueueInterfaceMockPull {
	if mmPull.mock.inspectFuncPull != nil {
		mmPull.mock.t.Fatalf("Inspect function is already set for QueueInterfaceMock.Pull")
	}

	mmPull.mock.inspectFuncPull = f

	return mmPull
}

// Return sets up results that will be returned by QueueInterface.Pull
func (mmPull *mQueueInterfaceMockPull) Return(q1 QueueNodeInt, err error) *QueueInterfaceMock {
	if mmPull.mock.funcPull != nil {
		mmPull.mock.t.Fatalf("QueueInterfaceMock.Pull mock is already set by Set")
	}

	if mmPull.defaultExpectation == nil {
		mmPull.defaultExpectation = &QueueInterfaceMockPullExpectation{mock: mmPull.mock}
	}
	mmPull.defaultExpectation.results = &QueueInterfaceMockPullResults{q1, err}
	return mmPull.mock
}

//Set uses given function f to mock the QueueInterface.Pull method
func (mmPull *mQueueInterfaceMockPull) Set(f func() (q1 QueueNodeInt, err error)) *QueueInterfaceMock {
	if mmPull.defaultExpectation != nil {
		mmPull.mock.t.Fatalf("Default expectation is already set for the QueueInterface.Pull method")
	}

	if len(mmPull.expectations) > 0 {
		mmPull.mock.t.Fatalf("Some expectations are already set for the QueueInterface.Pull method")
	}

	mmPull.mock.funcPull = f
	return mmPull.mock
}

// Pull implements QueueInterface
func (mmPull *QueueInterfaceMock) Pull() (q1 QueueNodeInt, err error) {
	mm_atomic.AddUint64(&mmPull.beforePullCounter, 1)
	defer mm_atomic.AddUint64(&mmPull.afterPullCounter, 1)

	if mmPull.inspectFuncPull != nil {
		mmPull.inspectFuncPull()
	}

	if mmPull.PullMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPull.PullMock.defaultExpectation.Counter, 1)

		mm_results := mmPull.PullMock.defaultExpectation.results
		if mm_results == nil {
			mmPull.t.Fatal("No results are set for the QueueInterfaceMock.Pull")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmPull.funcPull != nil {
		return mmPull.funcPull()
	}
	mmPull.t.Fatalf("Unexpected call to QueueInterfaceMock.Pull.")
	return
}

// PullAfterCounter returns a count of finished QueueInterfaceMock.Pull invocations
func (mmPull *QueueInterfaceMock) PullAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPull.afterPullCounter)
}

// PullBeforeCounter returns a count of QueueInterfaceMock.Pull invocations
func (mmPull *QueueInterfaceMock) PullBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPull.beforePullCounter)
}

// MinimockPullDone returns true if the count of the Pull invocations corresponds
// the number of defined expectations
func (m *QueueInterfaceMock) MinimockPullDone() bool {
	for _, e := range m.PullMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PullMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPullCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPull != nil && mm_atomic.LoadUint64(&m.afterPullCounter) < 1 {
		return false
	}
	return true
}

// MinimockPullInspect logs each unmet expectation
func (m *QueueInterfaceMock) MinimockPullInspect() {
	for _, e := range m.PullMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to QueueInterfaceMock.Pull")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PullMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPullCounter) < 1 {
		m.t.Error("Expected call to QueueInterfaceMock.Pull")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPull != nil && mm_atomic.LoadUint64(&m.afterPullCounter) < 1 {
		m.t.Error("Expected call to QueueInterfaceMock.Pull")
	}
}

type mQueueInterfaceMockPush struct {
	mock               *QueueInterfaceMock
	defaultExpectation *QueueInterfaceMockPushExpectation
	expectations       []*QueueInterfaceMockPushExpectation

	callArgs []*QueueInterfaceMockPushParams
	mutex    sync.RWMutex
}

// QueueInterfaceMockPushExpectation specifies expectation struct of the QueueInterface.Push
type QueueInterfaceMockPushExpectation struct {
	mock    *QueueInterfaceMock
	params  *QueueInterfaceMockPushParams
	results *QueueInterfaceMockPushResults
	Counter uint64
}

// QueueInterfaceMockPushParams contains parameters of the QueueInterface.Push
type QueueInterfaceMockPushParams struct {
	node QueueNodeInt
}

// QueueInterfaceMockPushResults contains results of the QueueInterface.Push
type QueueInterfaceMockPushResults struct {
	q1  QueueNodeInt
	err error
}

// Expect sets up expected params for QueueInterface.Push
func (mmPush *mQueueInterfaceMockPush) Expect(node QueueNodeInt) *mQueueInterfaceMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("QueueInterfaceMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &QueueInterfaceMockPushExpectation{}
	}

	mmPush.defaultExpectation.params = &QueueInterfaceMockPushParams{node}
	for _, e := range mmPush.expectations {
		if minimock.Equal(e.params, mmPush.defaultExpectation.params) {
			mmPush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPush.defaultExpectation.params)
		}
	}

	return mmPush
}

// Inspect accepts an inspector function that has same arguments as the QueueInterface.Push
func (mmPush *mQueueInterfaceMockPush) Inspect(f func(node QueueNodeInt)) *mQueueInterfaceMockPush {
	if mmPush.mock.inspectFuncPush != nil {
		mmPush.mock.t.Fatalf("Inspect function is already set for QueueInterfaceMock.Push")
	}

	mmPush.mock.inspectFuncPush = f

	return mmPush
}

// Return sets up results that will be returned by QueueInterface.Push
func (mmPush *mQueueInterfaceMockPush) Return(q1 QueueNodeInt, err error) *QueueInterfaceMock {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("QueueInterfaceMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &QueueInterfaceMockPushExpectation{mock: mmPush.mock}
	}
	mmPush.defaultExpectation.results = &QueueInterfaceMockPushResults{q1, err}
	return mmPush.mock
}

//Set uses given function f to mock the QueueInterface.Push method
func (mmPush *mQueueInterfaceMockPush) Set(f func(node QueueNodeInt) (q1 QueueNodeInt, err error)) *QueueInterfaceMock {
	if mmPush.defaultExpectation != nil {
		mmPush.mock.t.Fatalf("Default expectation is already set for the QueueInterface.Push method")
	}

	if len(mmPush.expectations) > 0 {
		mmPush.mock.t.Fatalf("Some expectations are already set for the QueueInterface.Push method")
	}

	mmPush.mock.funcPush = f
	return mmPush.mock
}

// When sets expectation for the QueueInterface.Push which will trigger the result defined by the following
// Then helper
func (mmPush *mQueueInterfaceMockPush) When(node QueueNodeInt) *QueueInterfaceMockPushExpectation {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("QueueInterfaceMock.Push mock is already set by Set")
	}

	expectation := &QueueInterfaceMockPushExpectation{
		mock:   mmPush.mock,
		params: &QueueInterfaceMockPushParams{node},
	}
	mmPush.expectations = append(mmPush.expectations, expectation)
	return expectation
}

// Then sets up QueueInterface.Push return parameters for the expectation previously defined by the When method
func (e *QueueInterfaceMockPushExpectation) Then(q1 QueueNodeInt, err error) *QueueInterfaceMock {
	e.results = &QueueInterfaceMockPushResults{q1, err}
	return e.mock
}

// Push implements QueueInterface
func (mmPush *QueueInterfaceMock) Push(node QueueNodeInt) (q1 QueueNodeInt, err error) {
	mm_atomic.AddUint64(&mmPush.beforePushCounter, 1)
	defer mm_atomic.AddUint64(&mmPush.afterPushCounter, 1)

	if mmPush.inspectFuncPush != nil {
		mmPush.inspectFuncPush(node)
	}

	mm_params := &QueueInterfaceMockPushParams{node}

	// Record call args
	mmPush.PushMock.mutex.Lock()
	mmPush.PushMock.callArgs = append(mmPush.PushMock.callArgs, mm_params)
	mmPush.PushMock.mutex.Unlock()

	for _, e := range mmPush.PushMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmPush.PushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPush.PushMock.defaultExpectation.Counter, 1)
		mm_want := mmPush.PushMock.defaultExpectation.params
		mm_got := QueueInterfaceMockPushParams{node}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPush.t.Errorf("QueueInterfaceMock.Push got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPush.PushMock.defaultExpectation.results
		if mm_results == nil {
			mmPush.t.Fatal("No results are set for the QueueInterfaceMock.Push")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmPush.funcPush != nil {
		return mmPush.funcPush(node)
	}
	mmPush.t.Fatalf("Unexpected call to QueueInterfaceMock.Push. %v", node)
	return
}

// PushAfterCounter returns a count of finished QueueInterfaceMock.Push invocations
func (mmPush *QueueInterfaceMock) PushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.afterPushCounter)
}

// PushBeforeCounter returns a count of QueueInterfaceMock.Push invocations
func (mmPush *QueueInterfaceMock) PushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.beforePushCounter)
}

// Calls returns a list of arguments used in each call to QueueInterfaceMock.Push.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPush *mQueueInterfaceMockPush) Calls() []*QueueInterfaceMockPushParams {
	mmPush.mutex.RLock()

	argCopy := make([]*QueueInterfaceMockPushParams, len(mmPush.callArgs))
	copy(argCopy, mmPush.callArgs)

	mmPush.mutex.RUnlock()

	return argCopy
}

// MinimockPushDone returns true if the count of the Push invocations corresponds
// the number of defined expectations
func (m *QueueInterfaceMock) MinimockPushDone() bool {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		return false
	}
	return true
}

// MinimockPushInspect logs each unmet expectation
func (m *QueueInterfaceMock) MinimockPushInspect() {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QueueInterfaceMock.Push with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		if m.PushMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to QueueInterfaceMock.Push")
		} else {
			m.t.Errorf("Expected call to QueueInterfaceMock.Push with params: %#v", *m.PushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		m.t.Error("Expected call to QueueInterfaceMock.Push")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QueueInterfaceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockPopInspect()

		m.MinimockPullInspect()

		m.MinimockPushInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QueueInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QueueInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPopDone() &&
		m.MinimockPullDone() &&
		m.MinimockPushDone()
}
