package learning

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i learning.PassengersQueueIface -o ./passengersqueue_mock.go -n PassengersQueueIfaceMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// PassengersQueueIfaceMock implements PassengersQueueIface
type PassengersQueueIfaceMock struct {
	t minimock.Tester

	funcList          func() (pa1 []Passenger)
	inspectFuncList   func()
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mPassengersQueueIfaceMockList

	funcPop          func(node Passenger) (p1 Passenger, err error)
	inspectFuncPop   func(node Passenger)
	afterPopCounter  uint64
	beforePopCounter uint64
	PopMock          mPassengersQueueIfaceMockPop

	funcPull          func() (p1 Passenger, err error)
	inspectFuncPull   func()
	afterPullCounter  uint64
	beforePullCounter uint64
	PullMock          mPassengersQueueIfaceMockPull

	funcPush          func(node Passenger) (p1 Passenger, err error)
	inspectFuncPush   func(node Passenger)
	afterPushCounter  uint64
	beforePushCounter uint64
	PushMock          mPassengersQueueIfaceMockPush
}

// NewPassengersQueueIfaceMock returns a mock for PassengersQueueIface
func NewPassengersQueueIfaceMock(t minimock.Tester) *PassengersQueueIfaceMock {
	m := &PassengersQueueIfaceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ListMock = mPassengersQueueIfaceMockList{mock: m}

	m.PopMock = mPassengersQueueIfaceMockPop{mock: m}
	m.PopMock.callArgs = []*PassengersQueueIfaceMockPopParams{}

	m.PullMock = mPassengersQueueIfaceMockPull{mock: m}

	m.PushMock = mPassengersQueueIfaceMockPush{mock: m}
	m.PushMock.callArgs = []*PassengersQueueIfaceMockPushParams{}

	return m
}

type mPassengersQueueIfaceMockList struct {
	mock               *PassengersQueueIfaceMock
	defaultExpectation *PassengersQueueIfaceMockListExpectation
	expectations       []*PassengersQueueIfaceMockListExpectation
}

// PassengersQueueIfaceMockListExpectation specifies expectation struct of the PassengersQueueIface.List
type PassengersQueueIfaceMockListExpectation struct {
	mock *PassengersQueueIfaceMock

	results *PassengersQueueIfaceMockListResults
	Counter uint64
}

// PassengersQueueIfaceMockListResults contains results of the PassengersQueueIface.List
type PassengersQueueIfaceMockListResults struct {
	pa1 []Passenger
}

// Expect sets up expected params for PassengersQueueIface.List
func (mmList *mPassengersQueueIfaceMockList) Expect() *mPassengersQueueIfaceMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("PassengersQueueIfaceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &PassengersQueueIfaceMockListExpectation{}
	}

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the PassengersQueueIface.List
func (mmList *mPassengersQueueIfaceMockList) Inspect(f func()) *mPassengersQueueIfaceMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for PassengersQueueIfaceMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by PassengersQueueIface.List
func (mmList *mPassengersQueueIfaceMockList) Return(pa1 []Passenger) *PassengersQueueIfaceMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("PassengersQueueIfaceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &PassengersQueueIfaceMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &PassengersQueueIfaceMockListResults{pa1}
	return mmList.mock
}

//Set uses given function f to mock the PassengersQueueIface.List method
func (mmList *mPassengersQueueIfaceMockList) Set(f func() (pa1 []Passenger)) *PassengersQueueIfaceMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the PassengersQueueIface.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the PassengersQueueIface.List method")
	}

	mmList.mock.funcList = f
	return mmList.mock
}

// List implements PassengersQueueIface
func (mmList *PassengersQueueIfaceMock) List() (pa1 []Passenger) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList()
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the PassengersQueueIfaceMock.List")
		}
		return (*mm_results).pa1
	}
	if mmList.funcList != nil {
		return mmList.funcList()
	}
	mmList.t.Fatalf("Unexpected call to PassengersQueueIfaceMock.List.")
	return
}

// ListAfterCounter returns a count of finished PassengersQueueIfaceMock.List invocations
func (mmList *PassengersQueueIfaceMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of PassengersQueueIfaceMock.List invocations
func (mmList *PassengersQueueIfaceMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *PassengersQueueIfaceMock) MinimockListDone() bool {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	return true
}

// MinimockListInspect logs each unmet expectation
func (m *PassengersQueueIfaceMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PassengersQueueIfaceMock.List")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		m.t.Error("Expected call to PassengersQueueIfaceMock.List")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		m.t.Error("Expected call to PassengersQueueIfaceMock.List")
	}
}

type mPassengersQueueIfaceMockPop struct {
	mock               *PassengersQueueIfaceMock
	defaultExpectation *PassengersQueueIfaceMockPopExpectation
	expectations       []*PassengersQueueIfaceMockPopExpectation

	callArgs []*PassengersQueueIfaceMockPopParams
	mutex    sync.RWMutex
}

// PassengersQueueIfaceMockPopExpectation specifies expectation struct of the PassengersQueueIface.Pop
type PassengersQueueIfaceMockPopExpectation struct {
	mock    *PassengersQueueIfaceMock
	params  *PassengersQueueIfaceMockPopParams
	results *PassengersQueueIfaceMockPopResults
	Counter uint64
}

// PassengersQueueIfaceMockPopParams contains parameters of the PassengersQueueIface.Pop
type PassengersQueueIfaceMockPopParams struct {
	node Passenger
}

// PassengersQueueIfaceMockPopResults contains results of the PassengersQueueIface.Pop
type PassengersQueueIfaceMockPopResults struct {
	p1  Passenger
	err error
}

// Expect sets up expected params for PassengersQueueIface.Pop
func (mmPop *mPassengersQueueIfaceMockPop) Expect(node Passenger) *mPassengersQueueIfaceMockPop {
	if mmPop.mock.funcPop != nil {
		mmPop.mock.t.Fatalf("PassengersQueueIfaceMock.Pop mock is already set by Set")
	}

	if mmPop.defaultExpectation == nil {
		mmPop.defaultExpectation = &PassengersQueueIfaceMockPopExpectation{}
	}

	mmPop.defaultExpectation.params = &PassengersQueueIfaceMockPopParams{node}
	for _, e := range mmPop.expectations {
		if minimock.Equal(e.params, mmPop.defaultExpectation.params) {
			mmPop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPop.defaultExpectation.params)
		}
	}

	return mmPop
}

// Inspect accepts an inspector function that has same arguments as the PassengersQueueIface.Pop
func (mmPop *mPassengersQueueIfaceMockPop) Inspect(f func(node Passenger)) *mPassengersQueueIfaceMockPop {
	if mmPop.mock.inspectFuncPop != nil {
		mmPop.mock.t.Fatalf("Inspect function is already set for PassengersQueueIfaceMock.Pop")
	}

	mmPop.mock.inspectFuncPop = f

	return mmPop
}

// Return sets up results that will be returned by PassengersQueueIface.Pop
func (mmPop *mPassengersQueueIfaceMockPop) Return(p1 Passenger, err error) *PassengersQueueIfaceMock {
	if mmPop.mock.funcPop != nil {
		mmPop.mock.t.Fatalf("PassengersQueueIfaceMock.Pop mock is already set by Set")
	}

	if mmPop.defaultExpectation == nil {
		mmPop.defaultExpectation = &PassengersQueueIfaceMockPopExpectation{mock: mmPop.mock}
	}
	mmPop.defaultExpectation.results = &PassengersQueueIfaceMockPopResults{p1, err}
	return mmPop.mock
}

//Set uses given function f to mock the PassengersQueueIface.Pop method
func (mmPop *mPassengersQueueIfaceMockPop) Set(f func(node Passenger) (p1 Passenger, err error)) *PassengersQueueIfaceMock {
	if mmPop.defaultExpectation != nil {
		mmPop.mock.t.Fatalf("Default expectation is already set for the PassengersQueueIface.Pop method")
	}

	if len(mmPop.expectations) > 0 {
		mmPop.mock.t.Fatalf("Some expectations are already set for the PassengersQueueIface.Pop method")
	}

	mmPop.mock.funcPop = f
	return mmPop.mock
}

// When sets expectation for the PassengersQueueIface.Pop which will trigger the result defined by the following
// Then helper
func (mmPop *mPassengersQueueIfaceMockPop) When(node Passenger) *PassengersQueueIfaceMockPopExpectation {
	if mmPop.mock.funcPop != nil {
		mmPop.mock.t.Fatalf("PassengersQueueIfaceMock.Pop mock is already set by Set")
	}

	expectation := &PassengersQueueIfaceMockPopExpectation{
		mock:   mmPop.mock,
		params: &PassengersQueueIfaceMockPopParams{node},
	}
	mmPop.expectations = append(mmPop.expectations, expectation)
	return expectation
}

// Then sets up PassengersQueueIface.Pop return parameters for the expectation previously defined by the When method
func (e *PassengersQueueIfaceMockPopExpectation) Then(p1 Passenger, err error) *PassengersQueueIfaceMock {
	e.results = &PassengersQueueIfaceMockPopResults{p1, err}
	return e.mock
}

// Pop implements PassengersQueueIface
func (mmPop *PassengersQueueIfaceMock) Pop(node Passenger) (p1 Passenger, err error) {
	mm_atomic.AddUint64(&mmPop.beforePopCounter, 1)
	defer mm_atomic.AddUint64(&mmPop.afterPopCounter, 1)

	if mmPop.inspectFuncPop != nil {
		mmPop.inspectFuncPop(node)
	}

	mm_params := &PassengersQueueIfaceMockPopParams{node}

	// Record call args
	mmPop.PopMock.mutex.Lock()
	mmPop.PopMock.callArgs = append(mmPop.PopMock.callArgs, mm_params)
	mmPop.PopMock.mutex.Unlock()

	for _, e := range mmPop.PopMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmPop.PopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPop.PopMock.defaultExpectation.Counter, 1)
		mm_want := mmPop.PopMock.defaultExpectation.params
		mm_got := PassengersQueueIfaceMockPopParams{node}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPop.t.Errorf("PassengersQueueIfaceMock.Pop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPop.PopMock.defaultExpectation.results
		if mm_results == nil {
			mmPop.t.Fatal("No results are set for the PassengersQueueIfaceMock.Pop")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmPop.funcPop != nil {
		return mmPop.funcPop(node)
	}
	mmPop.t.Fatalf("Unexpected call to PassengersQueueIfaceMock.Pop. %v", node)
	return
}

// PopAfterCounter returns a count of finished PassengersQueueIfaceMock.Pop invocations
func (mmPop *PassengersQueueIfaceMock) PopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPop.afterPopCounter)
}

// PopBeforeCounter returns a count of PassengersQueueIfaceMock.Pop invocations
func (mmPop *PassengersQueueIfaceMock) PopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPop.beforePopCounter)
}

// Calls returns a list of arguments used in each call to PassengersQueueIfaceMock.Pop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPop *mPassengersQueueIfaceMockPop) Calls() []*PassengersQueueIfaceMockPopParams {
	mmPop.mutex.RLock()

	argCopy := make([]*PassengersQueueIfaceMockPopParams, len(mmPop.callArgs))
	copy(argCopy, mmPop.callArgs)

	mmPop.mutex.RUnlock()

	return argCopy
}

// MinimockPopDone returns true if the count of the Pop invocations corresponds
// the number of defined expectations
func (m *PassengersQueueIfaceMock) MinimockPopDone() bool {
	for _, e := range m.PopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPop != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		return false
	}
	return true
}

// MinimockPopInspect logs each unmet expectation
func (m *PassengersQueueIfaceMock) MinimockPopInspect() {
	for _, e := range m.PopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PassengersQueueIfaceMock.Pop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		if m.PopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PassengersQueueIfaceMock.Pop")
		} else {
			m.t.Errorf("Expected call to PassengersQueueIfaceMock.Pop with params: %#v", *m.PopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPop != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		m.t.Error("Expected call to PassengersQueueIfaceMock.Pop")
	}
}

type mPassengersQueueIfaceMockPull struct {
	mock               *PassengersQueueIfaceMock
	defaultExpectation *PassengersQueueIfaceMockPullExpectation
	expectations       []*PassengersQueueIfaceMockPullExpectation
}

// PassengersQueueIfaceMockPullExpectation specifies expectation struct of the PassengersQueueIface.Pull
type PassengersQueueIfaceMockPullExpectation struct {
	mock *PassengersQueueIfaceMock

	results *PassengersQueueIfaceMockPullResults
	Counter uint64
}

// PassengersQueueIfaceMockPullResults contains results of the PassengersQueueIface.Pull
type PassengersQueueIfaceMockPullResults struct {
	p1  Passenger
	err error
}

// Expect sets up expected params for PassengersQueueIface.Pull
func (mmPull *mPassengersQueueIfaceMockPull) Expect() *mPassengersQueueIfaceMockPull {
	if mmPull.mock.funcPull != nil {
		mmPull.mock.t.Fatalf("PassengersQueueIfaceMock.Pull mock is already set by Set")
	}

	if mmPull.defaultExpectation == nil {
		mmPull.defaultExpectation = &PassengersQueueIfaceMockPullExpectation{}
	}

	return mmPull
}

// Inspect accepts an inspector function that has same arguments as the PassengersQueueIface.Pull
func (mmPull *mPassengersQueueIfaceMockPull) Inspect(f func()) *mPassengersQueueIfaceMockPull {
	if mmPull.mock.inspectFuncPull != nil {
		mmPull.mock.t.Fatalf("Inspect function is already set for PassengersQueueIfaceMock.Pull")
	}

	mmPull.mock.inspectFuncPull = f

	return mmPull
}

// Return sets up results that will be returned by PassengersQueueIface.Pull
func (mmPull *mPassengersQueueIfaceMockPull) Return(p1 Passenger, err error) *PassengersQueueIfaceMock {
	if mmPull.mock.funcPull != nil {
		mmPull.mock.t.Fatalf("PassengersQueueIfaceMock.Pull mock is already set by Set")
	}

	if mmPull.defaultExpectation == nil {
		mmPull.defaultExpectation = &PassengersQueueIfaceMockPullExpectation{mock: mmPull.mock}
	}
	mmPull.defaultExpectation.results = &PassengersQueueIfaceMockPullResults{p1, err}
	return mmPull.mock
}

//Set uses given function f to mock the PassengersQueueIface.Pull method
func (mmPull *mPassengersQueueIfaceMockPull) Set(f func() (p1 Passenger, err error)) *PassengersQueueIfaceMock {
	if mmPull.defaultExpectation != nil {
		mmPull.mock.t.Fatalf("Default expectation is already set for the PassengersQueueIface.Pull method")
	}

	if len(mmPull.expectations) > 0 {
		mmPull.mock.t.Fatalf("Some expectations are already set for the PassengersQueueIface.Pull method")
	}

	mmPull.mock.funcPull = f
	return mmPull.mock
}

// Pull implements PassengersQueueIface
func (mmPull *PassengersQueueIfaceMock) Pull() (p1 Passenger, err error) {
	mm_atomic.AddUint64(&mmPull.beforePullCounter, 1)
	defer mm_atomic.AddUint64(&mmPull.afterPullCounter, 1)

	if mmPull.inspectFuncPull != nil {
		mmPull.inspectFuncPull()
	}

	if mmPull.PullMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPull.PullMock.defaultExpectation.Counter, 1)

		mm_results := mmPull.PullMock.defaultExpectation.results
		if mm_results == nil {
			mmPull.t.Fatal("No results are set for the PassengersQueueIfaceMock.Pull")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmPull.funcPull != nil {
		return mmPull.funcPull()
	}
	mmPull.t.Fatalf("Unexpected call to PassengersQueueIfaceMock.Pull.")
	return
}

// PullAfterCounter returns a count of finished PassengersQueueIfaceMock.Pull invocations
func (mmPull *PassengersQueueIfaceMock) PullAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPull.afterPullCounter)
}

// PullBeforeCounter returns a count of PassengersQueueIfaceMock.Pull invocations
func (mmPull *PassengersQueueIfaceMock) PullBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPull.beforePullCounter)
}

// MinimockPullDone returns true if the count of the Pull invocations corresponds
// the number of defined expectations
func (m *PassengersQueueIfaceMock) MinimockPullDone() bool {
	for _, e := range m.PullMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PullMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPullCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPull != nil && mm_atomic.LoadUint64(&m.afterPullCounter) < 1 {
		return false
	}
	return true
}

// MinimockPullInspect logs each unmet expectation
func (m *PassengersQueueIfaceMock) MinimockPullInspect() {
	for _, e := range m.PullMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PassengersQueueIfaceMock.Pull")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PullMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPullCounter) < 1 {
		m.t.Error("Expected call to PassengersQueueIfaceMock.Pull")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPull != nil && mm_atomic.LoadUint64(&m.afterPullCounter) < 1 {
		m.t.Error("Expected call to PassengersQueueIfaceMock.Pull")
	}
}

type mPassengersQueueIfaceMockPush struct {
	mock               *PassengersQueueIfaceMock
	defaultExpectation *PassengersQueueIfaceMockPushExpectation
	expectations       []*PassengersQueueIfaceMockPushExpectation

	callArgs []*PassengersQueueIfaceMockPushParams
	mutex    sync.RWMutex
}

// PassengersQueueIfaceMockPushExpectation specifies expectation struct of the PassengersQueueIface.Push
type PassengersQueueIfaceMockPushExpectation struct {
	mock    *PassengersQueueIfaceMock
	params  *PassengersQueueIfaceMockPushParams
	results *PassengersQueueIfaceMockPushResults
	Counter uint64
}

// PassengersQueueIfaceMockPushParams contains parameters of the PassengersQueueIface.Push
type PassengersQueueIfaceMockPushParams struct {
	node Passenger
}

// PassengersQueueIfaceMockPushResults contains results of the PassengersQueueIface.Push
type PassengersQueueIfaceMockPushResults struct {
	p1  Passenger
	err error
}

// Expect sets up expected params for PassengersQueueIface.Push
func (mmPush *mPassengersQueueIfaceMockPush) Expect(node Passenger) *mPassengersQueueIfaceMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("PassengersQueueIfaceMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &PassengersQueueIfaceMockPushExpectation{}
	}

	mmPush.defaultExpectation.params = &PassengersQueueIfaceMockPushParams{node}
	for _, e := range mmPush.expectations {
		if minimock.Equal(e.params, mmPush.defaultExpectation.params) {
			mmPush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPush.defaultExpectation.params)
		}
	}

	return mmPush
}

// Inspect accepts an inspector function that has same arguments as the PassengersQueueIface.Push
func (mmPush *mPassengersQueueIfaceMockPush) Inspect(f func(node Passenger)) *mPassengersQueueIfaceMockPush {
	if mmPush.mock.inspectFuncPush != nil {
		mmPush.mock.t.Fatalf("Inspect function is already set for PassengersQueueIfaceMock.Push")
	}

	mmPush.mock.inspectFuncPush = f

	return mmPush
}

// Return sets up results that will be returned by PassengersQueueIface.Push
func (mmPush *mPassengersQueueIfaceMockPush) Return(p1 Passenger, err error) *PassengersQueueIfaceMock {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("PassengersQueueIfaceMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &PassengersQueueIfaceMockPushExpectation{mock: mmPush.mock}
	}
	mmPush.defaultExpectation.results = &PassengersQueueIfaceMockPushResults{p1, err}
	return mmPush.mock
}

//Set uses given function f to mock the PassengersQueueIface.Push method
func (mmPush *mPassengersQueueIfaceMockPush) Set(f func(node Passenger) (p1 Passenger, err error)) *PassengersQueueIfaceMock {
	if mmPush.defaultExpectation != nil {
		mmPush.mock.t.Fatalf("Default expectation is already set for the PassengersQueueIface.Push method")
	}

	if len(mmPush.expectations) > 0 {
		mmPush.mock.t.Fatalf("Some expectations are already set for the PassengersQueueIface.Push method")
	}

	mmPush.mock.funcPush = f
	return mmPush.mock
}

// When sets expectation for the PassengersQueueIface.Push which will trigger the result defined by the following
// Then helper
func (mmPush *mPassengersQueueIfaceMockPush) When(node Passenger) *PassengersQueueIfaceMockPushExpectation {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("PassengersQueueIfaceMock.Push mock is already set by Set")
	}

	expectation := &PassengersQueueIfaceMockPushExpectation{
		mock:   mmPush.mock,
		params: &PassengersQueueIfaceMockPushParams{node},
	}
	mmPush.expectations = append(mmPush.expectations, expectation)
	return expectation
}

// Then sets up PassengersQueueIface.Push return parameters for the expectation previously defined by the When method
func (e *PassengersQueueIfaceMockPushExpectation) Then(p1 Passenger, err error) *PassengersQueueIfaceMock {
	e.results = &PassengersQueueIfaceMockPushResults{p1, err}
	return e.mock
}

// Push implements PassengersQueueIface
func (mmPush *PassengersQueueIfaceMock) Push(node Passenger) (p1 Passenger, err error) {
	mm_atomic.AddUint64(&mmPush.beforePushCounter, 1)
	defer mm_atomic.AddUint64(&mmPush.afterPushCounter, 1)

	if mmPush.inspectFuncPush != nil {
		mmPush.inspectFuncPush(node)
	}

	mm_params := &PassengersQueueIfaceMockPushParams{node}

	// Record call args
	mmPush.PushMock.mutex.Lock()
	mmPush.PushMock.callArgs = append(mmPush.PushMock.callArgs, mm_params)
	mmPush.PushMock.mutex.Unlock()

	for _, e := range mmPush.PushMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmPush.PushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPush.PushMock.defaultExpectation.Counter, 1)
		mm_want := mmPush.PushMock.defaultExpectation.params
		mm_got := PassengersQueueIfaceMockPushParams{node}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPush.t.Errorf("PassengersQueueIfaceMock.Push got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPush.PushMock.defaultExpectation.results
		if mm_results == nil {
			mmPush.t.Fatal("No results are set for the PassengersQueueIfaceMock.Push")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmPush.funcPush != nil {
		return mmPush.funcPush(node)
	}
	mmPush.t.Fatalf("Unexpected call to PassengersQueueIfaceMock.Push. %v", node)
	return
}

// PushAfterCounter returns a count of finished PassengersQueueIfaceMock.Push invocations
func (mmPush *PassengersQueueIfaceMock) PushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.afterPushCounter)
}

// PushBeforeCounter returns a count of PassengersQueueIfaceMock.Push invocations
func (mmPush *PassengersQueueIfaceMock) PushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.beforePushCounter)
}

// Calls returns a list of arguments used in each call to PassengersQueueIfaceMock.Push.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPush *mPassengersQueueIfaceMockPush) Calls() []*PassengersQueueIfaceMockPushParams {
	mmPush.mutex.RLock()

	argCopy := make([]*PassengersQueueIfaceMockPushParams, len(mmPush.callArgs))
	copy(argCopy, mmPush.callArgs)

	mmPush.mutex.RUnlock()

	return argCopy
}

// MinimockPushDone returns true if the count of the Push invocations corresponds
// the number of defined expectations
func (m *PassengersQueueIfaceMock) MinimockPushDone() bool {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		return false
	}
	return true
}

// MinimockPushInspect logs each unmet expectation
func (m *PassengersQueueIfaceMock) MinimockPushInspect() {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PassengersQueueIfaceMock.Push with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		if m.PushMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PassengersQueueIfaceMock.Push")
		} else {
			m.t.Errorf("Expected call to PassengersQueueIfaceMock.Push with params: %#v", *m.PushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		m.t.Error("Expected call to PassengersQueueIfaceMock.Push")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PassengersQueueIfaceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockListInspect()

		m.MinimockPopInspect()

		m.MinimockPullInspect()

		m.MinimockPushInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PassengersQueueIfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PassengersQueueIfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockListDone() &&
		m.MinimockPopDone() &&
		m.MinimockPullDone() &&
		m.MinimockPushDone()
}
